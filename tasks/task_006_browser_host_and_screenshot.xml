<gemini_cli_task>
  <context>
    We are building "SmartChrome", embedding a local VLM into Chromium. 
    Current Phase: Connecting MOD_01_FRONTEND_ENGINE -> Browser Process.
    Task 005 successfully sent the A11y JSON from the Renderer. Now, we must implement the receiver in the Browser process (`VLMPageHostImpl`). When it receives the JSON, it must immediately capture a screenshot of the WebContents (viewport) to complete the multi-modal payload for the VLM.
  </context>

  <phase_1_project_management>
    <description>Save this prompt to the SmartChrome GitHub repo.</description>
    <actions>
      <action>Save this entire XML prompt text into: `~/SmartChrome/tasks/task_006_browser_host_and_screenshot.xml`</action>
      <action>Change directory to `~/SmartChrome`.</action>
      <action>Execute: `git add tasks/task_006_browser_host_and_screenshot.xml`</action>
      <action>Execute: `git commit -m "task: implement browser process mojo receiver and viewport screenshot capture"`</action>
      <action>Execute: `git push`</action>
    </actions>
  </phase_1_project_management>

  <phase_2_chromium_execution>
    <description>Create the Browser process receiver and integrate Skia screenshot capture.</description>
    <actions>
      <action>Change directory to your Chromium source tree (`~/chromium/src`).</action>
      
      <action>Create header file `components/vlm_agent/browser/vlm_page_host_impl.h`:</action>
      <file_content path="components/vlm_agent/browser/vlm_page_host_impl.h">
#ifndef COMPONENTS_VLM_AGENT_BROWSER_VLM_PAGE_HOST_IMPL_H_
#define COMPONENTS_VLM_AGENT_BROWSER_VLM_PAGE_HOST_IMPL_H_

#include "components/vlm_agent/public/mojom/vlm_agent.mojom.h"
#include "content/public/browser/document_user_data.h"
#include "content/public/browser/web_contents.h"
#include "mojo/public/cpp/bindings/associated_receiver.h"
#include "mojo/public/cpp/bindings/pending_receiver.h"
#include "mojo/public/cpp/bindings/receiver.h"
#include "third_party/skia/include/core/SkBitmap.h"
#include "base/memory/weak_ptr.h"

namespace vlm_agent {

// Lives in the Browser process. Receives A11y data from the Renderer
// and captures the viewport screenshot. Tied to the lifecycle of a Document.
class VLMPageHostImpl : public content::DocumentUserData<VLMPageHostImpl>,
                        public mojom::VLMPageHost {
 public:
  ~VLMPageHostImpl() override;

  // Binds the Mojo receiver. Called from the browser's interface broker.
  static void BindReceiver(
      content::RenderFrameHost* render_frame_host,
      mojo::PendingReceiver<mojom::VLMPageHost> receiver);

  // mojom::VLMPageHost implementation:
  void OnA11yTreeUpdated(const std::string& a11y_json) override;

 private:
  explicit VLMPageHostImpl(content::RenderFrameHost* render_frame_host);
  friend class content::DocumentUserData<VLMPageHostImpl>;
  DOCUMENT_USER_DATA_KEY_DECL();

  // Callback when the GPU surface copy (screenshot) finishes.
  void OnScreenshotCaptured(std::string a11y_json, const SkBitmap& bitmap);

  mojo::Receiver<mojom::VLMPageHost> receiver_{this};
  base::WeakPtrFactory<VLMPageHostImpl> weak_ptr_factory_{this};
};

}  // namespace vlm_agent

#endif  // COMPONENTS_VLM_AGENT_BROWSER_VLM_PAGE_HOST_IMPL_H_
      </file_content>

      <action>Create implementation file `components/vlm_agent/browser/vlm_page_host_impl.cc`:</action>
      <file_content path="components/vlm_agent/browser/vlm_page_host_impl.cc">
#include "components/vlm_agent/browser/vlm_page_host_impl.h"
#include "content/public/browser/render_frame_host.h"
#include "content/public/browser/render_widget_host_view.h"
#include "content/public/browser/web_contents.h"
#include "base/logging.h"
#include "ui/gfx/geometry/rect.h"
#include "ui/gfx/geometry/size.h"

namespace vlm_agent {

DOCUMENT_USER_DATA_KEY_IMPL(VLMPageHostImpl);

VLMPageHostImpl::VLMPageHostImpl(content::RenderFrameHost* render_frame_host)
    : content::DocumentUserData<VLMPageHostImpl>(render_frame_host) {}

VLMPageHostImpl::~VLMPageHostImpl() = default;

// static
void VLMPageHostImpl::BindReceiver(
    content::RenderFrameHost* render_frame_host,
    mojo::PendingReceiver<mojom::VLMPageHost> receiver) {
  if (!render_frame_host || !render_frame_host->IsActive()) {
    return;
  }
  
  auto* host = VLMPageHostImpl::GetOrCreateForCurrentDocument(render_frame_host);
  host->receiver_.Bind(std::move(receiver));
}

void VLMPageHostImpl::OnA11yTreeUpdated(const std::string& a11y_json) {
  content::RenderFrameHost* rfh = &render_frame_host();
  if (!rfh) return;

  content::RenderWidgetHostView* view = rfh->GetView();
  if (!view) {
    LOG(WARNING) << "VLMPageHost: No RenderWidgetHostView, cannot take screenshot.";
    return;
  }

  // Capture the visual state of the viewport precisely when the A11y tree updates
  view->CopyFromSurface(
      gfx::Rect(), gfx::Size(),
      base::BindOnce(&VLMPageHostImpl::OnScreenshotCaptured,
                     weak_ptr_factory_.GetWeakPtr(), a11y_json));
}

void VLMPageHostImpl::OnScreenshotCaptured(std::string a11y_json, const SkBitmap& bitmap) {
  if (bitmap.drawsNothing()) {
    LOG(ERROR) << "VLMPageHost: Screenshot capture failed (empty bitmap).";
    return;
  }

  // The payload is now complete!
  LOG(INFO) << "==========================================";
  LOG(INFO) << "VLM Payload Ready!";
  LOG(INFO) << "Screenshot Size: " << bitmap.width() << "x" << bitmap.height();
  LOG(INFO) << "A11y JSON Length: " << a11y_json.length() << " bytes";
  LOG(INFO) << "==========================================";

  // Next Step: Forward `bitmap` and `a11y_json` to the isolated VLM Utility Process.
}

}  // namespace vlm_agent
      </file_content>

      <action>Update build configurations in `components/vlm_agent/BUILD.gn`. Ensure the `sources` list includes `browser/vlm_page_host_impl.h` and `browser/vlm_page_host_impl.cc`. Ensure `deps` includes `//components/vlm_agent/public/mojom`, `//content/public/browser`, `//ui/gfx/geometry`, `//skia`, and `//base`.</action>
      <action>Execute build: `autoninja -C out/Default components/vlm_agent`</action>
    </actions>
  </phase_2_chromium_execution>

  <execution_directive>
    Execute Phase 1 to log the task. Then execute Phase 2. Autonomously inspect Chromium source if `DocumentUserData` or `CopyFromSurface` includes require adjustment. Fix the GN build file and retry until the build succeeds. Report the final exit code.
  </execution_directive>
</gemini_cli_task>
